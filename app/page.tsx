"use client";

import React, { useState } from "react";
import { useSpeechRecognition } from "../hooks/useSpeechRecognition";
import {
  analyzeTextWithWolfram,
  WolframFeatures,
} from "../services/wolframService";
import { generateGeminiPrompt } from "../utils/promptUtils";
import { ImageSelector } from "../components/ImageSelector";
import { FeatureChecklist } from "../components/FeatureChecklist";
import { CharacterFeaturesHelp } from "../components/CharacterFeaturesHelp";

type Step = "input" | "verification" | "generating" | "selection";

// Replace this with the URL generated by the second Wolfram script (convert-to-sketch)
const WOLFRAM_SKETCH_API = "https://www.wolframcloud.com/obj/rnavarroe1700/api/convert-to-sketch";

export default function Home() {
  const {
    text,
    setText,
    isListening,
    startListening,
    stopListening,
    resetText,
    hasRecognitionSupport,
    error: speechError,
  } = useSpeechRecognition();

  const [step, setStep] = useState<Step>("input");
  const [features, setFeatures] = useState<WolframFeatures>({});
  const [extraDescription, setExtraDescription] = useState("");
  const [prompt, setPrompt] = useState("");
  const [generatedImages, setGeneratedImages] = useState<string[]>([]);
  const [selectedImageIndex, setSelectedImageIndex] = useState<number | null>(
    null
  );
  const [wolframError, setWolframError] = useState<string | null>(null);
  const [generationError, setGenerationError] = useState<string | null>(null);

  // ---------------------------------------------------------------------------
  // Helpers
  // ---------------------------------------------------------------------------

  const updateFeature = (
    section: keyof WolframFeatures,
    field: string,
    value: string
  ) => {
    setFeatures((prev) => ({
      ...prev,
      [section]: {
        ...(prev[section] || {}),
        [field]: value,
      },
    }));
  };

  const basicFieldsMissing = () => {
    const faceShape = features.face?.shape;
    const eyebrowType = features.eyebrows?.type;

    return !faceShape || !eyebrowType;
  };

  // ---------------------------------------------------------------------------
  // 1) Speech-to-text -> Wolfram
  // ---------------------------------------------------------------------------

  const processTextToFeatures = async () => {
    setWolframError(null);
    setGenerationError(null);

    try {
      const response = await analyzeTextWithWolfram(text);
      if (response.features) {
        setFeatures(response.features);
      } else {
        setFeatures({});
      }

      // Create an initial base prompt (it can be regenerated after editing)
      const initialPrompt = generateGeminiPrompt(response.features ?? {});
      setPrompt(initialPrompt);

      setStep("verification");
    } catch (err: any) {
      console.error("Error processing text in Wolfram:", err);
      setWolframError(
        err.message || "Error processing text in Wolfram Cloud"
      );
    }
  };

  // Build the final prompt and call Gemini
  // ... inside the Home component in page.tsx ...

  const generatePortraits = async (overridePrompt?: string) => {
    const finalPrompt = overridePrompt ?? prompt;
    if (!finalPrompt) return;

    setStep("generating");
    setGenerationError(null);
    setGeneratedImages([]);
    setSelectedImageIndex(null);

    try {
      // --- STEP 1: Generate realistic images with Gemini ---
      console.log("[1/4] Starting request to Gemini...");
      const response = await fetch("/api/generate-portrait", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ prompt: finalPrompt }),
      });

      const data = await response.json();

      if (!response.ok) {
        const errorMessage = data.error || "Error in Gemini API";
        const details = data.details ? JSON.stringify(data.details, null, 2) : "";
        throw new Error(`${errorMessage}\n${details}`);
      }

      // Get array of images
      let rawImages: string[] = [];
      if (data.results && Array.isArray(data.results)) {
        rawImages = data.results;
      } else if (data.result || data.image) {
        rawImages = [data.result || data.image];
      } else {
        throw new Error("No images received from Gemini");
      }

      console.log(`[2/4] Gemini generated ${rawImages.length} images.`);

      // --- STEP 2: Convert to Sketch with Wolfram ---
      console.log("[3/4] Sending to Wolfram Cloud for sketch effect...");

      // Cleanup: remove the "data:image..." header
      const cleanBase64List = rawImages.map((img) => img.split(",")[1]);

      // Debug: Verify we're not sending empty strings
      console.log(`   -> Image 1 size: ${cleanBase64List[0].length} characters`);

      const wolframFormData = new FormData();
      wolframFormData.append("imagesJson", JSON.stringify(cleanBase64List));

      // Make sure you have the WOLFRAM_SKETCH_API constant defined above
      const wolframResponse = await fetch(WOLFRAM_SKETCH_API, {
        method: "POST",
        headers: {
          "Content-Type": "application/json", // Required header to avoid 400 errors
        },
        body: JSON.stringify({
          images: cleanBase64List, // The 'images' key must match {"images" -> "JSON"} in Wolfram
        }),
      });

      console.log(`   -> Wolfram status: ${wolframResponse.status}`);

      if (!wolframResponse.ok) {
        console.warn("Wolfram failed. Showing Gemini originals.");
        setGeneratedImages(rawImages);
      } else {
        const sketchesBase64: string[] = await wolframResponse.json();
        console.log(
          `[4/4] Wolfram responded successfully. ${sketchesBase64.length} sketches received.`
        );

        // Reconstruct the images
        const finalImages = sketchesBase64.map((b64) => `data:image/png;base64,${b64}`);
        setGeneratedImages(finalImages);
      }

      setSelectedImageIndex(0);
      setStep("selection");
    } catch (err: any) {
      console.error("CRITICAL Error in generatePortraits:", err);
      setGenerationError(err.message || "Unknown error");
      setStep("verification");
    }
  };

  const handleConfirmAndGenerate = () => {
    // Merge any extra user description into the JSON payload
    const mergedFeatures: WolframFeatures = {
      ...features,
      otherFeatures:
        extraDescription || features.otherFeatures || null,
    };

    const finalPrompt = generateGeminiPrompt(mergedFeatures);
    setPrompt(finalPrompt);
    generatePortraits(finalPrompt);
  };

  const handleDownload = () => {
    if (selectedImageIndex === null) return;
    const link = document.createElement("a");
    link.href = generatedImages[selectedImageIndex];
    link.download = `spoken-portrait-${Date.now()}.png`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // RENDER

  return (
    <main className="min-h-screen bg-black text-gray-100 font-sans">
      <header className="border-b border-gray-800 bg-gray-900/60 backdrop-blur-md sticky top-0 z-10">
        <div className="max-w-4xl mx-auto px-6 py-4 flex items-center justify-between">
          <h1 className="text-xl font-bold tracking-tight text-white">
            DeepSketch
          </h1>
          <span className="text-xs text-gray-500">
            AI-Assisted Composite Sketches
          </span>
        </div>
      </header>

      <div className="max-w-4xl mx-auto px-6 py-10 space-y-10">
        {/* Simple visual steps */}
        <div className="flex justify-between text-xs text-gray-400">
          {["Capture", "Verification", "Generation", "Selection"].map(
            (label, idx) => {
              const steps: Step[] = [
                "input",
                "verification",
                "generating",
                "selection",
              ];
              const currentIdx = steps.indexOf(step);
              const isActive = idx <= currentIdx;
              return (
                <div key={label} className="flex flex-col items-center gap-1">
                  <div
                    className={`w-7 h-7 rounded-full flex items-center justify-center text-xs font-bold ${
                      isActive
                        ? "bg-blue-600 text-white"
                        : "bg-gray-800 text-gray-500"
                    }`}
                  >
                    {idx + 1}
                  </div>
                  <span
                    className={
                      isActive ? "text-blue-400" : "text-gray-600"
                    }
                  >
                    {label}
                  </span>
                </div>
              );
            }
          )}
        </div>

        {/* STEP 1: INPUT */}
        {step === "input" && (
          <section className="space-y-6">
            <h2 className="text-2xl font-bold">Subject Description</h2>
            <p className="text-sm text-gray-400">
              Use the microphone or manually type the physical description of
              the subject.
            </p>
            <CharacterFeaturesHelp/>

            <div className="bg-gray-900/60 border border-gray-800 rounded-xl p-4 space-y-3">
              <textarea
                value={text}
                onChange={(e) => setText(e.target.value)}
                placeholder="Ex: Young man, elongated face, light brown skin, almond-shaped brown eyes, thick eyebrows..."
                className="w-full h-40 bg-black/40 border border-gray-800 rounded-lg px-3 py-2 text-sm text-gray-200 placeholder-gray-600 focus:outline-none focus:ring-1 focus:ring-blue-500"
              />

              <div className="flex justify-between items-center">
                <button
                  type="button"
                  onClick={() =>
                    setText(
                      "Man about 20 years old, diamond-shaped face, almond-shaped brown eyes, thick eyebrows, medium aquiline nose, thick lips, round chin, short wavy dark brown hair."
                    )
                  }
                  className="hover:cursor-pointer text-xs text-gray-500 hover:text-gray-300 underline"
                >
                  Load example
                </button>

                <div className="flex items-center gap-2">
                  {hasRecognitionSupport ? (
                    <button
                      type="button"
                      onClick={isListening ? stopListening : startListening}
                      className={`hover:cursor-pointer px-3 py-2 rounded-md text-xs font-medium flex items-center gap-2 ${
                        isListening
                          ? "bg-red-600 text-white"
                          : "bg-blue-600 text-white"
                      }`}
                    >
                      {isListening ? "Stop microphone" : "Speak"}
                    </button>
                  ) : (
                    <span className="text-xs text-red-400">
                      No voice recognition support
                    </span>
                  )}

                  <button
                    type="button"
                    onClick={resetText}
                    className="hover:cursor-pointer px-3 py-2 rounded-md text-xs border border-gray-700 text-gray-300 hover:bg-gray-800"
                  >
                    Clear
                  </button>
                </div>
              </div>

              {speechError && (
                <p className="text-xs text-red-400 mt-1">{speechError}</p>
              )}
            </div>

            <div className="flex justify-end">
              <button
                type="button"
                onClick={processTextToFeatures}
                className="hover:cursor-pointer px-5 py-2 rounded-md bg-green-600 text-white text-sm font-medium hover:bg-green-500"
                disabled={!text.trim()}
              >
                Send to Wolfram
              </button>
            </div>

            {wolframError && (
              <p className="text-sm text-red-400">{wolframError}</p>
            )}
          </section>
        )}

        {/* STEP 2: VERIFICATION */}
        {step === "verification" && (
          <section className="space-y-6">
            <h2 className="text-2xl font-bold">Data Verification</h2>
            <p className="text-sm text-gray-400">
              Review and complete the features before generating the image.
            </p>

            <FeatureChecklist features={features} />

            {/* Basic editable fields */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 bg-gray-900/60 border border-gray-800 rounded-xl p-4">
              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Face shape
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.face?.shape ?? ""}
                  onChange={(e) =>
                    updateFeature("face", "shape", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Skin tone
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.face?.skinTone ?? ""}
                  onChange={(e) =>
                    updateFeature("face", "skinTone", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Eye color
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.eyes?.color ?? ""}
                  onChange={(e) =>
                    updateFeature("eyes", "color", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Eyebrow type
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.eyebrows?.type ?? ""}
                  onChange={(e) =>
                    updateFeature("eyebrows", "type", e.target.value)
                  }
                />
              </div>

              {/* Nose */}
              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Nose size
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.nose?.size ?? ""}
                  onChange={(e) =>
                    updateFeature("nose", "size", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Nose shape
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.nose?.shape ?? ""}
                  onChange={(e) =>
                    updateFeature("nose", "shape", e.target.value)
                  }
                />
              </div>

              {/* Mouth */}
              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Mouth size
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.mouth?.size ?? ""}
                  onChange={(e) =>
                    updateFeature("mouth", "size", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Lips
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.mouth?.lips ?? ""}
                  onChange={(e) =>
                    updateFeature("mouth", "lips", e.target.value)
                  }
                />
              </div>

              {/* Hair */}
              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Hair color
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.hair?.color ?? ""}
                  onChange={(e) =>
                    updateFeature("hair", "color", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Hair length
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.hair?.length ?? ""}
                  onChange={(e) =>
                    updateFeature("hair", "length", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Hair density
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.hair?.density ?? ""}
                  onChange={(e) =>
                    updateFeature("hair", "density", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Style / hairstyle
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.hair?.style ?? ""}
                  onChange={(e) =>
                    updateFeature("hair", "style", e.target.value)
                  }
                />
              </div>

              {/* Body */}
              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Build
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.body?.build ?? ""}
                  onChange={(e) =>
                    updateFeature("body", "build", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Posture
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.body?.posture ?? ""}
                  onChange={(e) =>
                    updateFeature("body", "posture", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Skin tone (body)
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.body?.tone ?? ""}
                  onChange={(e) =>
                    updateFeature("body", "tone", e.target.value)
                  }
                />
              </div>

              <div>
                <label className="block text-xs text-gray-500 mb-1">
                  Approximate weight
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.body?.weight ?? ""}
                  onChange={(e) =>
                    updateFeature("body", "weight", e.target.value)
                  }
                />
              </div>

              {/* Clothing */}
              <div className="md:col-span-2">
                <label className="block text-xs text-gray-500 mb-1">
                  Clothing / attire type
                </label>
                <input
                  type="text"
                  className="w-full bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                  value={features.clothing ?? ""}
                  onChange={(e) =>
                    // Update the top-level clothing property directly
                    setFeatures((prev) => ({ ...prev, clothing: e.target.value }))
                  }
                />
              </div>
            </div>

            {/* Extra characteristics */}
            <div className="bg-gray-900/60 border border-gray-800 rounded-xl p-4 space-y-2">
              <label className="block text-xs text-gray-500 mb-1">
                Special features (scars, moles, tattoos,
                accessories, etc.)
              </label>
              <textarea
                className="w-full h-24 bg-black/40 border border-gray-800 rounded px-2 py-1 text-sm text-gray-200"
                value={extraDescription}
                onChange={(e) => setExtraDescription(e.target.value)}
                placeholder="Ex: Has a scar on the right eyebrow, wears black rectangular glasses..."
              />

              {/* Raw JSON view for debugging */}
              <details className="mt-2 text-xs text-gray-500">
                <summary className="cursor-pointer">
                  View complete features JSON
                </summary>
                <pre className="mt-2 p-2 bg-black rounded text-[10px] text-green-400 overflow-auto max-h-52">
                  {JSON.stringify(features, null, 2)}
                </pre>
              </details>
            </div>

            {/* Prompt that will be sent to Gemini */}
            <div className="bg-gray-900/60 border border-gray-800 rounded-xl p-4">
              <h3 className="text-sm font-semibold text-gray-200 mb-2">
                Current prompt:
              </h3>
              <pre className="text-xs text-gray-300 whitespace-pre-wrap bg-black/40 rounded p-2 max-h-40 overflow-auto">
                {prompt}
              </pre>
              {basicFieldsMissing() && (
                <p className="mt-2 text-xs text-yellow-400">
                  Warning: Some basic fields are missing (for example: face
                  shape, eye color or eyebrow type).
                </p>
              )}
            </div>

            {generationError && (
              <p className="text-sm text-red-400">{generationError}</p>
            )}

            <div className="flex justify-between">
              <button
                type="button"
                onClick={() => setStep("input")}
                className="hover:cursor-pointer px-4 py-2 rounded-md border border-gray-700 text-xs text-gray-300 hover:bg-gray-800"
              >
                Back to capture
              </button>

              <button
                type="button"
                onClick={handleConfirmAndGenerate}
                className="hover:cursor-pointer px-5 py-2 rounded-md bg-blue-600 text-white text-sm font-medium hover:bg-blue-500"
              >
                Confirm and generate image
              </button>
            </div>
          </section>
        )}

        {/* STEP 3: GENERATING */}
        {step === "generating" && (
          <section className="flex flex-col items-center justify-center py-16 gap-4">
            <div className="w-16 h-16 border-4 border-gray-700 border-t-blue-500 rounded-full animate-spin" />
            <p className="text-sm text-gray-400 text-center max-w-sm">
              Generating the portrait from the description. This may take
              a few seconds...
            </p>
          </section>
        )}

        {/* STEP 4: SELECTION */}
        {step === "selection" && (
          <section className="space-y-6">
            <h2 className="text-2xl font-bold">Generated Results</h2>
            <p className="text-sm text-gray-400">
              Select the image that best matches the description.
            </p>

            <ImageSelector
              images={generatedImages}
              selectedImageIndex={selectedImageIndex}
              onSelect={setSelectedImageIndex}
            />

            <div className="flex justify-between items-center pt-4">
              <button
                type="button"
                onClick={() => setStep("verification")}
                className="hover:cursor-pointer px-4 py-2 rounded-md border border-gray-700 text-xs text-gray-300 hover:bg-gray-800"
              >
                Back to verification
              </button>

              <div className="flex gap-3">
                <button
                  type="button"
                  onClick={handleDownload}
                  disabled={selectedImageIndex === null}
                  className="hover:cursor-pointer px-4 py-2 rounded-md bg-green-600 disabled:bg-green-900/60 text-white text-xs font-medium"
                >
                  Download image
                </button>
              </div>
            </div>
          </section>
        )}
      </div>
    </main>
  );
}















